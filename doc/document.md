> 是的，我有点标题党了。但是有时候就是这个样子，你不知道对方要什么，对方也解释不清自己想要什么，你即要顺应变化，还要满足对方的需要，如何解决？在软件编程领域有很多设计模式可以解决这个问题，以及这里将要用到的微内核架构。都是比较常见的用于解决复杂抽象问题的设计模式，还有面向对象原则来度量设计模式的使用是否正确。

# 写一个校验库。但是却没有校验功能 ---- `What`？

写一个没有校验功能的校验库，听起来就是下图一样的感受。

![](/doc/images/1.jpeg)

是的，但是挑战就在那里。就像前几年网络流行的一个梗：五彩斑斓的黑。最后还是被广大网友找到了答案。

## 为什么要搞一个没有校验功能的校验库 ---- `Why`？
`JS`校验库，我们往往会想到`validator.js`，已经是一个非常优秀的校验库了。并且提供了扩展接口，通过不同的`rule`组合来满足不同的业务场景需要。但是往往也会带来一个问题，业务代码臃肿。同一个`team`不同的人在同一个工程中可能会写很多重复的`rule`。那么为什么要解决这个问题呢？

这就是我面临的挑战。
- 降低研发人员写校验逻辑的开发成本
- 业务无关，业务方可以通过添加插件的形式任意接入和定制化自己的校验规则
- 校验规则最大化可复用，提高开发效率
- 水平扩展能力，通过微内核架构模式提供插件注册机制来满足水平扩展的需要，这也是非常重要的一点
- 这几天比较狂躁，需要给自己找点有挑战的事情虐一下自己，充实一下自己。

## 如何去实现这样一个校验库呢 ---- `How`？
编程领域有很多解决各种问题的方法，那么需要用哪些方法来解决这个问题呢？如何判断这个方法是否使用的合理呢？答案就是 ---- `设计模式`与`面向对象五大原则`（在这里我一定要想大家安利一本书《敏捷软件开发:原则、模式与实践》）

### `微内核架构`
何为`微内核架构`呢？简单来说就是`插件化架构`。将不同的功能以`插件`的形式，集成到系统中。将不同的功能以`插件`的形式进行拆分，然后通过安装各种功能的`插件`到系统中来扩展系统的功能以实现水平扩展的能力。

![](/doc/images/2.png)

通过`微内核架构`，我们可以清晰的看到，每个功能点，都做成一个`插件`，插入到系统中。而这些`插件`，通过`微内核架构`的调度能力去调度，在系统内部有选择的运行`插件`以满足业务需要。所以基本的工作流程应该是下面这个样子：

![](/doc/images/3.png)

那么如何去实现这样一个`微内核架构`呢？在这里我必须介绍两个  非常重要的`设计模式` -- `解析器模式`&`中介者模式`。当然在实现的代码里面并没有完全依照这几个模式的定义去实现，但是起到的作用和实现思路是相同的。

### `解析器模式`
这是对`解析器模式`的解释：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。

之所以需要使用`解析器模式`，主要是它非常适合用来实现`微内核架构`，通过`解析器`提供一个校验规则组件的统一`接口规范`。用户方只需要按照接口规则，实现自己的`校验组件`，然后添加到`解析器`中，这样`解析器`就具备了该校验能力。

那么如何去实现一个`解析器模式`呢？`解析器模式`如何帮助我们实现一个`微内核架构`呢？请看看下面的类图。

![](/doc/images/4.png)

不过遗憾的是`JS`并没有`接口类型`，所以，在实际实现的时候只能利用`JS`特有的一些语言特性用另一种方式来实现。比如`Validator`的静态属性`plugins`通过沙盒内的闭包来实现对用户的隐藏和隔离，静态方法`addPlugin`是通过在`Validator`类上直接添加一个方法。

```js
const plugins = {}

function doValidate(schema = {}, target = {}) {
  // 此处省略
}

class Validator {
  constructor(schema = {}) {
    // 此处省略
  }

  validate(target = {}) {
    // 此处省略
  }
}

Validator.addPlugin = function (plugin, replace = false) {
  // 此处省略
}
```

通过沙盒模式实现对私有方法和属性进行隐藏从而对外部进行隔离。而对于接口`IPlugin`就只有通过参数的约束来进行限制了。

### `中介者模式`
对于`中介者模式`，大家可能会非常陌生，但是在大家的代码多多少少都可以找到它的身影。它是这么被定义的：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

如果说整个`微内核架构`是通过`解释器模式`实现的，那么`Validator`类就可以认为是一个`中介对象`。通过中介者`Validator`的接口`validate`，将校验规则`Schema`与待校验对象`Target`进行解耦。通过`中介者`内部，根据`Schema`对校验规则的描述，调用指定校验组件，对待校验对象`Target`进行处理。

这样，校验规则和待校验对象都可以相互独立的变化，然后通过中介者进行关联。

![](/doc/images/5.png)

## 如何验证运用的设计模式是否合理呢?
这里就要不得不提`面向对象五大原则`。有人会问，这是`面向对象五大原则`，我们又不是用`Java`，也可以不用`Class`去实现啊。

但是`面向对象五大原则`又没用说必须使用`类`不是？而且对其它编程范式也同样的有指导作用。可以度量我们对`设计模式`的使用是否正确。

### `接口与实现分离原则`
这里在微内核架构的实现中就对`Plugin`的相关实现，其实就是遵循`接口与实现分离原则`。为什么这么说？

在上面的类图中是这么描述的，`addPlugin`的参数类型是`IPlugin`，而`IPlugin`是一个接口，那么只要实现了接口的对象就可以在`Validator`中正确运行。那么我们可以传入一个校验电话号码的`Plugin`，一个校验邮箱的`Plugin`，对于`Validator`来说，它并不关心你传入的`Plugin`是什么，它只关心你传入的`Plugin`是否实现了约定的接口。

因此，在遵循了`接口与实现分离原则`之后，`Validator`任意校验规则水平扩展的能力。而我们平时总挂载嘴边的`低耦合高内聚`，到底什么是`低耦合高内聚`呢？那么微内核`Validator`和校验实现`Plugin`就是一种`低耦合高内聚`。

### `单一职责原则`
我们也使用了`单一职责原则`。所谓`单一职责`，并不是我们常说的一个封装只做一件事情。比如表单，他就做表单的事情？其实这种理解是错的，而这种理解也往往会催生很多不合理的过度设计。比如组件的过度封装。基本上是我在经历过的所有前端项目中肯定会见到的。

那么如何理解`单一职责`呢?`单一职责`我比较认可的一个解释是：修改的原因只有一个。

比如在这里，我的框架需要支持对象属性和数组属性，以及数组中对象元素的校验。这个时候我需要在`doValidate`中做修改以支持更多的类型，进行递归校验。Ok这是没问题的，因为本身`Validator`就是一个调度器。调度规则发生改变，调度器去做修改。

那么有一天，我们需要支持异步的校验能力，比如通过接口进行校验。联动校验，比如需要依赖表单的另一个项目才能知道这个目标字段是否正确。那么这个时候，显然这种校验规则发生了变化。而目前的`Validator`又不支持。那么就需要通过改变`IPlugin`接口才能满足需要。

而`IPlugin`接口的实现正是用于实现具体的校验规则的抽象。那么也就是说`Validator`依赖于`IPlugin`接口的实现这个方案也是遵守单一职责的。

> *从上面的解释，大家也许也可以看到，面向对象原则并不是独立存在的。而是相互影响相互制约的，所以我要再一次安利这本书`《敏捷软件开发:原则、模式与实践》`。*

## 最后

附上源代码[源码](https://github.com/ryouaki/validator) 欢迎提供Star！